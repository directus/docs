---
title: Testing
description: How to run unit and blackbox tests in the Directus codebase.
---

Directus has two main methods of testing, being through unit and blackbox tests.  Unit tests are located in each package and can be run from the pacakage itself. Blackbox tests on the other hand are located in `tests/blackbox`.

## Running tests

### Unit tests
```bash
# Run from the package that you want to start the tests from
pnpm test
```

### Blackbox tests

::callout{icon="material-symbols:warning-rounded" color="info"}
[Docker](https://docs.docker.com/get-docker/) is required to run extensions locally.
::

```bash
# Test against directus running with postgres
pnpm test

# Test against all databases
pnpm test:all

# Test against a specific database. The project option can be used multiple times to test against multiple different databases at the same time.
pnpm vitest --project sqlite
```

### Vitest options

Both unit and blackbox tests are running through [Vitest](https://vitest.dev) and thus support all options that vitest has to offer for customizing what tests to run.

```bash
# Run all tests that have "permission" in their filename.
pnpm test permissions

# Run all tests and watch for changes in the test files.
pnpm test -w
```

For more options, see [here](https://vitest.dev/guide/cli.html).

## Writing unit tests

Unit Tests are written throughout the codebase in a vite native unit test framework called [Vitest](https://vitest.dev).

```ts 
import { afterEach, beforeEach, expect, test, vi } from 'vitest';

import { formatTitle } from './format-title.js';

test('should format utc string', () => {
	const result = formatTitle('hello-world')

	expect(result).toBe('Hello World');
});
```

## Writing blackbox tests

The basic test structure goes as follows.

1. (optionally) Create a new folder for your tests
2. Create your test file, ending with `.test.ts`
3. You can start with this template:

```ts
import { createDirectus, rest, serverPing, staticToken } from '@directus/sdk';
import { useSnapshot } from '@utils/useSnapshot.js';
import { expect, test } from 'vitest';

import { port } from '@utils/constants.js';
import type { Schema } from './schema.js';

const api = createDirectus<Schema>(`http://localhost:${port}`).with(rest()).with(staticToken('admin'));

const { collections } = await useSnapshot<Schema>(api);

test('ping', async () => {
	const result = await api.request(serverPing());

	expect(result).toBe('pong');
});
```

### Using a custom schema

Blackbox tests allow you to easily setup custom schemas for testing using the `useSnapshot` function. By default, the function uses the `snapshot.json` file that should be located on the same level as your test file.

In oder to create such a schema and types for said schema quickly, use the sandbox cli:

```bash
# Run this in the same folder as your tests
sandbox -s -x postgres
```

The `-x` option hereby exports the schema every 2s and the `-s` starts the directus instance using a preexisting `snapshot.json` so editing an exisitng snapshot is also quickly possible.

When creating collections, make that each collection ends with `_1234` as this is required to ensure that each collection will have a uniqe name in the blackbox tests. 

### Avoiding naming conflicts

If you manually want to create collections or other things like users, you have to make sure that these are unique across tests runs and different tests.
A good way to do that is either to use the `getUID()` or `randomUUID()` functions. `getUID()` returns a string unique to the file that you're currently running in but returns the same string for there same file whereas `randomUUID()` will awalys return a random UUID.

### Launching a custom directus instance

It is possible to spin up separate directus instances inside of a test file itself. This is useful if you want to test against cases with e.g. horizontal scaling.

```ts
import { sandbox } from '@directus/sandbox';
import { database } from '@utils/constants.js';
import getPort from 'get-port';
import { getUID } from '@utils/getUID.js';

const port = await getPort()

const directus = await sandbox(database, {
		port,
		schema: join(import.meta.dirname, 'snapshot.json'), // Custom schema to start the instance with
		inspect: false,
		silent: true,
		docker: {
			basePort: port + 1,
			suffix: getUID(), // make sure this is unique as it could collide with other docker project names 
		},
	});
```

::callout{icon="material-symbols:info-outline" color="info"}
For more information about the configuration options for the sandbox cli, see [here](/community/codebase/sandbox-cli).
::
